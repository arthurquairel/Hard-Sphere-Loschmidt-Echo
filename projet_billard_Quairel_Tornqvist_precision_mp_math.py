# -*- coding: utf-8 -*-
"""Projet_billard3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RoZQZpUO2qqRvbohQnrA4N6YyA7lJh1K
"""

# Importation
import numpy as np
from mpmath import mp
import math
import time
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.collections import EllipseCollection, LineCollection
from IPython.display import HTML
from IPython.display import display # Import display to show the HTML animation
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib import rc
import random

mp.dps = 50

class Simul:
    """
    This is the prototype of the simulation code.
    All calculations are done using mpmath.mpf for arbitrary precision.
    """
    def __init__(self, simul_time, sigma, L, W, eps, nframes, velo, dps):
        np.seterr(all='ignore')  # Supprime de possibles erreurs de floatant
        mp.dps = dps # fixe la précision
        position = []
        velocity = []

        # Positions et vitesses initiales des particules et du projectile
        for i in range(5):
            for j in range(i + 1):
                position.append([mp.mpf(L/2) + np.sqrt(3)*(mp.mpf(sigma) + 100*mp.mpf(eps))*i, mp.mpf(W/2) + (mp.mpf(sigma) + 100*mp.mpf(eps))*(i - 2*j)])
        position.append([mp.mpf(L/4), mp.mpf(W/2)])

        for i in range(15):
            velocity.append([mp.mpf(0), mp.mpf(0)])
        velocity.append([mp.mpf(velo[0]), mp.mpf(velo[1])])

        self.velocity = np.array([np.array([mp.mpf(v[0]), mp.mpf(v[1])]) for v in velocity])
        Bruit = eps*np.random.normal(size=self.velocity.shape)
        Bruit = np.array([np.array([mp.mpf(b[0]), mp.mpf(b[1])]) for b in Bruit])
        self.position = np.array([np.array([mp.mpf(p[0]), mp.mpf(p[1])]) for p in position]) + Bruit


        self.l, self.m = np.triu_indices(self.position.shape[0], k=1) # les paires de particules
        self.sigma = mp.mpf(sigma)  # rayon des particules
        self.simul_time = mp.mpf(simul_time)
        # dimension de la boite
        self.L = mp.mpf(L)
        self.W = mp.mpf(W)

        self.nframes = nframes
        # On conserve les vitesses et positions initiales
        self.position_initiale = self.position.copy()
        self.velocity_initiale = self.velocity.copy()

        self.compteur_Loss_position = 0
        self.nombre_choc = 0
        self.compteur_Loss_velocity = 0

    def wall_time(self): # On calcul le temps de collision avec la paroie, la première particule qui s'est choquée avec la paroie
        upper_wall_limits = np.array([self.L - self.sigma, self.W - self.sigma])
        lower_wall_limits = np.array([self.sigma, self.sigma])

        temps = np.full(self.position.shape, mp.inf) # On initialise à l'infinie les temps

        # On regarde si les vitesses sont nulles
        non_zero_vel_mask = (self.velocity != 0)

        # On calcul les temps pour des vitesses positives et une vitesse non nulle
        positive_vel_and_non_zero_mask = (self.velocity > 0) & non_zero_vel_mask
        temps[positive_vel_and_non_zero_mask] = (upper_wall_limits - self.position)[positive_vel_and_non_zero_mask] / self.velocity[positive_vel_and_non_zero_mask]

        # On calcul les temps pour des vitesses negatives et une vitesse non nulle
        negative_vel_and_non_zero_mask = (self.velocity < 0) & non_zero_vel_mask
        temps[negative_vel_and_non_zero_mask] = (lower_wall_limits - self.position)[negative_vel_and_non_zero_mask] / self.velocity[negative_vel_and_non_zero_mask]

        temps = np.where(temps > 0, temps, mp.inf) # On s'assure que les temps sont positifs

        w_time = np.min(temps) # On prend le minimum des temps de collisions

        particle, direction = np.unravel_index(np.argmin(temps), self.position.shape) # On recupère la particule qui a touché la paroie
        return w_time, particle, direction

    def pair_time(self): # On calcul le temps de collision entre deux particules, les deux premières particule qui se sont choqués
        deltaV = self.velocity[self.l] - self.velocity[self.m]
        deltaP = self.position[self.l] - self.position[self.m]

        A = np.sum(deltaV**2, axis=1)
        B = 2 * np.sum(deltaV * deltaP, axis=1)
        C = np.sum(deltaP**2, axis=1) - (2 * self.sigma)**2

        Delta = B**2 - 4 * A * C

        temps = np.full(A.shape, mp.inf) # On initialise à l'infinie les temps

        valid_collision_mask = (A != 0) & (C > 0) & (Delta >= 0) & (B < 0) # On verifie que les conditions sur A, B et C sont verifiées

        temps[valid_collision_mask] = (-B[valid_collision_mask] - np.sqrt(Delta[valid_collision_mask])) / (2 * A[valid_collision_mask]) # On calcul le temps de collision

        arg_t_min = np.argmin(temps)

        return temps[arg_t_min], self.l[arg_t_min], self.m[arg_t_min]

    def vitesse_choc(self, particle1, particle2): # On calcul les vitesses après le chocs entre deux particules
        U = (self.position[particle1] - self.position[particle2]) / (2 * self.sigma)
        V = self.velocity[particle1] - self.velocity[particle2]
        self.velocity[particle1] -= U * np.dot(U, V)
        self.velocity[particle2] += U * np.dot(U, V)

    def md_step(self, current_frame):
        ke_start = (self.velocity**2).sum() / 2. # energie cinétique

        pressure = mp.mpf(-1) # pression
        current_time = mp.mpf(0)

        if current_frame == self.nframes // 2: # On inverse toutes les vitesses à la moitié du temps totale de simulation
            self.velocity *= -1

        w_time, particle, direction = self.wall_time()
        c_time, particle1, particle2 = self.pair_time()
        next_time = min(w_time, c_time)

        while current_time + next_time < self.simul_time:
            current_time += next_time
            self.position += next_time * self.velocity

            if w_time < c_time: # Une particule touche d'abord une paroie
                self.velocity[particle, direction] = -self.velocity[particle, direction]
            else:  # deux particules se touchent en premier
                self.vitesse_choc(particle1, particle2)
                self.nombre_choc += 1

            w_time, particle, direction = self.wall_time()
            c_time, particle1, particle2 = self.pair_time()
            next_time = min(w_time, c_time)

        self.position += (self.simul_time - current_time) * self.velocity

        # On calcul les erreurs des positions et des vitesses entre la fin et le début de la simulation
        if current_frame == self.nframes:
            self.compteur_Loss_position = np.sum(np.abs(self.position - self.position_initiale))
            self.compteur_Loss_velocity = np.sum(np.abs(self.velocity + self.velocity_initiale))

        assert math.isclose(ke_start, (self.velocity**2).sum() / 2.)  # On verifie que l'énergie cinétique est conservée

        return pressure

    def __str__(self):  # this is used to print the position and velocity of the particles
        p = np.array2string(self.position)
        v = np.array2string(self.velocity)
        return 'pos= ' + p + '\n' + 'vel= ' + v + '\n'

class Animate:
    def __init__(self, simul):
        self.simul = simul
        self.fig, self.ax = plt.subplots(figsize=(5, 5))  # initialise graphics
        # Convertir les positions en float pour les graphiques
        self.circles = EllipseCollection(widths=2*simul.sigma, heights=2*simul.sigma, angles=0, units='x',
                                         offsets=self.convert_to_float(simul.position), transOffset=self.ax.transData)  # circles at position
        self.ax.add_collection(self.circles)
        self.ax.axis("equal")

        # Segment pour la cellule de simulation (en float)
        # Modified: Convert simul.L and simul.W to float directly
        self.segment = [[[0, 0], [0, float(simul.W)], [float(simul.L), float(simul.W)], [float(simul.L), 0], [0, 0]]]
        # Modified: Remove the call to self.convert_to_float
        self.line = LineCollection(self.segment, colors='#000000')  # draw square
        self.ax.add_collection(self.line)

        # Convert simul.L and simul.W to float when setting axis limits
        self.ax.set_xlim(left=-0.5, right=float(self.simul.L) + 0.5)  # plotting limits on screen
        self.ax.set_ylim(bottom=-0.5, top=float(self.simul.W) + 0.5)
        self._ani = 0

    def convert_to_float(self, array):
        """Convertit un tableau de mpmath.mpf en un tableau de float."""
        # Cette ligne parcourt chaque point (coordonnée) dans le tableau et convertit chaque coordonnée en float
        return np.array([[float(coord) for coord in point] for point in array])

    def init(self):  # this is the first thing drawn to the screen
        self.circles.set_offsets(self.convert_to_float(self.simul.position))  # Convertir en float avant d'afficher

    def anim_step(self, m):  # m is the number of calls that have occurred to this function
        #print('anim_step m = ', m) # Commented out to avoid excessive output
        if m == 0:
            time.sleep(1)

        self.simul.md_step(m)  # perform simulation step
        # Convertir les positions en float avant de mettre à jour les positions à l'écran
        self.circles.set_offsets(self.convert_to_float(self.simul.position))  # update positions on screen

    def go(self, nframes):
        self._ani = animation.FuncAnimation(self.fig, func=self.anim_step, frames=nframes,
                                            repeat=False, interval=10, init_func=self.init)
        plt.close(self.fig)  # Close the plot to prevent it from showing twice
        return HTML(self._ani.to_jshtml())  # Return HTML for Colab display

"""On remarque que pour 35 chiffres significatifs il n'y a plus d'erreur numérique(ou très faiblement) alors qu'avec des floatants (pour une même vitesse 15 et un même nombre de frame 1000) l'erreur était significatif.

(temps d'exécution 39 secondes pour 500 frames)

Nous avons bien montré une amélioration de la précision numérique
"""

# 1. Configuration pour Colab (Mode JavaScript)
rc('animation', html='jshtml')

# 2. Création de la figure
fig, ax = plt.subplots(figsize=(5,5))
x = np.linspace(0, 2*np.pi, 100)
line, = ax.plot(x, np.sin(x))

# 3. Fonction d'animation (appelée à chaque image)
def update(frame):
    # On décale l'onde sinusoïdale
    line.set_ydata(np.sin(x + frame / 10.0))
    return line,

# 4. Création de l'objet animation
# IMPORTANT : Il faut assigner le résultat à une variable ("anim" ici)
# sinon le "garbage collector" de Python risque de supprimer l'animation.
anim = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True)

# 5. Affichage (Evite d'avoir une image statique en double)
plt.close() # Ferme la figure statique précédente
anim # Affiche le lecteur interactif


def main():
    mp.dps = 35 # Précisions
    np.random.seed(1)  # graine
    nframes = 500
    debut = time.time()
    simulation = Simul(simul_time=mp.mpf(0.2), sigma=1, L=50, W = 50, eps = mp.mpf(10**(-4)), nframes=nframes, velo = [mp.mpf(15),mp.mpf(0)], dps = 35)  # simulation
    print(simulation.__doc__)  # print the documentation from the class

    animate = Animate(simulation) # animation

    ani_html = animate.go(nframes=nframes)  # number of animation steps
    display(ani_html) # Display the HTML animation
    fin = time.time()
    print("Le temps d'exécution en seconde est : ",fin-debut) # Temps d'exécution du programme

if __name__ == '__main__':
    main()

"""Pour réduire le temps d'exécution, on supprime la simulation qui est couteuse en temps et on détermine l'erreur des positions et des vitesses des particules.

Nous obtenons des erreurs très faibles par rapport à l'utilisation de floatant (pour la même vitesse initiale et le même nombre de frames)

(temps d'exécution 10 secondes pour 1000 frames)
"""

def main():
    np.random.seed(1)  # set random numbers to be always the same
    nframes = 1000
    debut = time.time()
    simulation = Simul(simul_time=mp.mpf(0.2), sigma=1, L=50, W = 50, eps = mp.mpf(10**(-4)), nframes=nframes, velo = [mp.mpf(15),mp.mpf(0)], dps = 35)
    print(simulation.__doc__)  # print the documentation from the clas
    for j in range(nframes+1):
          simulation.md_step(j)
    fin = time.time()
    print("Le temps d'exécution est : ", fin-debut)
    print("Erreur de position :", simulation.compteur_Loss_position)
    print("Erreur de vitesse :", simulation.compteur_Loss_velocity)

if __name__ == '__main__':
  main()

"""Nous allons maintenant trouver la nouvelle vitesse critique pour 35 chiffres significatifs.

(temps d'exécution 11 minutes)

Nous observons bien une augmentation de la vitesse critique.
"""

def main(N, M, V_i, V_f):
    np.random.seed(1)  # graine plus facile pour détecter les erreurs
    nframes = 1000

    L_position = []
    L_velocity = []
    N_choc = []
    for i in np.linspace(V_i,V_f,N):
      compteur_Lp  = 0
      compteur_choc = 0
      compteur_Lv = 0
      for m in range(M):
        simulation = Simul(simul_time=mp.mpf(0.2), sigma=1, L=50, W = 50, eps = mp.mpf(10**(-4)), nframes=nframes, velo = [mp.mpf(i),mp.mpf(0)], dps = 35)
        for j in range(nframes+1):
          simulation.md_step(j)
        compteur_Lp += simulation.compteur_Loss_position
        compteur_Lv += simulation.compteur_Loss_velocity
        compteur_choc += simulation.nombre_choc
      L_position.append(compteur_Lp/M)
      L_velocity.append(compteur_Lv/M)
      N_choc.append(compteur_choc/M)
    return L_position, L_velocity, N_choc

N = 20 # Nombre de valeurs
M = 3 # moyenne sur M
V_i = 10 #vitesse initiale
V_f = 35 #vitesse finale


if __name__ == '__main__':
    L_position2, L_velocity2, N_choc2 = main(N, M, V_i, V_f)

plt.plot(np.linspace(V_i,V_f,N),  np.array(L_position2)/max(L_position2), 'b-', label='position')
plt.plot(np.linspace(V_i,V_f,N), np.array(L_velocity2)/max(L_velocity2), 'g-', label='velocity')
plt.title("Erreur des positions et des vitesses normalisées en fonction de la vitesse initiale")
plt.ylabel(r"Erreur des positions et des vitesses normalisées")
plt.xlabel(r"V_i")
plt.legend()

"""Nous faisons maintenant varier le nombre de chiffres significatifs avec le même nombre de frame et la même vitesse initiale et nous regardons l'évolution des erreurs.


(temps d'exécution 1 minutes)
"""

def main(N, D_i, D_f):
    np.random.seed(1)  # graine plus facile pour détecter les erreurs
    nframes = 1000

    L_position = []
    L_velocity = []
    N_choc = []
    Temps = []
    for i in range(D_i,D_f,N):
      debut = time.time()
      simulation = Simul(simul_time=mp.mpf(0.2), sigma=1, L=50, W = 50, eps = mp.mpf(10**(-4)), nframes=nframes, velo = [mp.mpf(15),mp.mpf(0)], dps = i)
      for j in range(nframes+1):
          simulation.md_step(j)
      fin = time.time()
      L_position.append(simulation.compteur_Loss_position)
      L_velocity.append(simulation.compteur_Loss_velocity)
      N_choc.append(simulation.nombre_choc)
      Temps.append(fin-debut)
    return L_position, L_velocity, N_choc, Temps

N = 5
D_i = 10 # nombre de chiffres significatifs initiales
D_f = 50 #  nombre de chiffres significatifs finales


if __name__ == '__main__':
    L_position1, L_velocity1, N_choc1, Temps1 = main(N, D_i, D_f)

fig, axs = plt.subplots(2, 2, figsize=(10, 10),constrained_layout=True)


# Premier sous-graphe (en haut à gauche)
axs[0, 0].plot(range(D_i,D_f,N),  L_position1, 'b-', label='log(L_position)')
axs[0, 0].set_title("Erreur des positions en fonction du nombre de chiffres significatifs")
axs[0, 0].set_ylabel(r"Erreur des positions")
axs[0, 0].set_xlabel(r"Nombre de chiffres significatifs")
axs[0, 0].legend()


# Deuxième sous-graphe (en haut à droite)
axs[0, 1].plot(range(D_i,D_f,N), L_velocity1, 'g-')
axs[0, 1].set_title("Erreur des vitesses en fonction du nombre de chiffres significatifs")
axs[0, 0].set_ylabel(r"Erreur des vitesses")
axs[0, 0].set_xlabel(r"Nombre de chiffres significatifs")
axs[0, 1].legend()

# Troisième sous-graphe (en bas à gauche)
axs[1, 0].plot(range(D_i,D_f,N), N_choc1, 'r-')
axs[1, 0].set_title("Nombre de chocs en fonction du nombre de chiffres significatifs")
axs[1, 0].set_ylabel(r"$N_{choc}$")
axs[1, 0].set_xlabel(r"Nombre de chiffres significatifs")
axs[1, 0].legend()

# Quatrième sous-graphe (en bas à droite)
axs[1, 1].plot(range(D_i,D_f,N), np.array(Temps1) , 'r-')
axs[1, 1].set_title("Temps d'exécution en fonction du nombre de chiffres significatifs")
axs[1, 1].set_ylabel(r"Temps d'exécution")
axs[1, 1].set_xlabel(r"Nombre de chiffres significatifs")
axs[1, 1].legend()

plt.tight_layout()
plt.subplots_adjust(hspace=0.3, wspace=0.7)
plt.show()

"""On moyenne avec M valeurs et on est plus précis.

On remarque bien que plus la précision est importante moins il y a d'erreurs numériques.

(temps d'exécution 1h30)
"""

def main(M, D_i, D_f):
    nframes = 1000

    L_position = []
    L_velocity = []
    N_choc = []
    Temps = []
    for i in range(D_i,D_f):
      compteur_Lp  = 0
      compteur_choc = 0
      compteur_Lv = 0
      compteur_temps = 0
      for m in range(M):
        debut = time.time()
        simulation = Simul(simul_time=mp.mpf(0.2), sigma=1, L=50, W = 50, eps = mp.mpf(10**(-4)), nframes=nframes, velo = [mp.mpf(15),mp.mpf(0)], dps = i)
        for j in range(nframes+1):
            simulation.md_step(j)
        fin = time.time()
        compteur_Lp += simulation.compteur_Loss_position
        compteur_Lv += simulation.compteur_Loss_velocity
        compteur_choc += simulation.nombre_choc
        compteur_temps += fin-debut
      L_position.append(compteur_Lp/m)
      L_velocity.append(compteur_Lv/m)
      N_choc.append(compteur_choc/m)
      Temps.append(compteur_temps)
    return L_position, L_velocity, N_choc, Temps

M = 10
D_i = 10
D_f = 50


if __name__ == '__main__':
    L_position, L_velocity, N_choc, Temps = main(M, D_i, D_f)

fig, axs = plt.subplots(4, 1, figsize=(10, 20))

with mp.workdps(50):
    L_position_max = max(L_position)
    L_velocity_max = max(L_velocity)


# Premier sous-graphe (en haut à gauche)
axs[0].plot(range(D_i,D_f),  L_position, 'b-')
axs[0].set_title("Erreur des positions en fonction du nombre de chiffres significatifs")
axs[0].set_ylabel(r"Erreurs de positions")
axs[0].set_xlabel(r"Nombre de chiffres significatifs")
axs[0].legend()


# Deuxième sous-graphe (en haut à droite)
axs[2].plot(range(D_i,D_f),  np.array(L_position)/L_position_max, 'b-', label = "position")
axs[2].plot(range(D_i,D_f), np.array(L_velocity)/L_velocity_max, 'g-', label = "velocity")
axs[2].set_title("Erreurs des positions et des vitesses moyennes en fonction du nombre de chiffres significatifs")
axs[2].set_ylabel(r"Erreurs de positions et de vitesses normalisées")
axs[2].set_xlabel(r"Nombre de chiffres significatifs")
axs[2].legend()

# Troisième sous-graphe (en bas à gauche)
axs[1].plot(range(D_i,D_f), N_choc, 'g-')
axs[1].set_title("Nombre de chocs en fonction du nombre de chiffres significatifs")
axs[1].set_ylabel(r"$N_{choc}$")
axs[1].set_xlabel(r"Nombre de chiffres significatifs")
axs[1].legend()

# Quatrième sous-graphe (en bas à droite)
axs[3].plot(range(D_i,D_f), np.array(Temps)/M , 'r-')
axs[3].set_title("Temps d'exécution en fonction du nombre de chiffres significatifs")
axs[3].set_ylabel(r"Temps d'exécution en moyenne")
axs[3].set_xlabel(r"Nombre de chiffres significatifs")
axs[3].legend()

plt.tight_layout()