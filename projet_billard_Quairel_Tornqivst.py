# -*- coding: utf-8 -*-
"""Projet_billard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dOcoiIT6fTII4twNlHyH2eedge3ZQ3oQ
"""

# Importation
import numpy as np
import math
import time
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.collections import EllipseCollection, LineCollection
from IPython.display import HTML
from IPython.display import display
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib import rc
import random

class Simul:

    def __init__(self, simul_time, sigma, L, W, eps, nframes, velo):
        np.seterr(all='ignore')
        position = []
        velocity = []

        # Positions et vitesses initiales des particules et du projectile
        for i in range(5):
          for j in range(i+1):
            position.append([L/2+np.sqrt(3)*(sigma+100*eps)*i,W/2+(sigma+100*eps)*(i-2*j)])
        position.append([L/4,W/2])

        for i in range (15) :
          velocity.append([0,0])
        velocity.append(velo)

        self.velocity = np.array(velocity, dtype = 'float')
        self.position = np.array(position, dtype = 'float')  + eps * np.random.normal(size=self.velocity.shape)


        self.l, self.m = np.triu_indices(self.position.shape[0], k=1)  # les paires de particules
        self.sigma = sigma  # rayon des particules
        self.simul_time = simul_time
        # dimension de la boite
        self.L = L
        self.W = W
        self.nframes = nframes

        # On conserve les vitesses et positions initiales
        self.position_initiale = self.position.copy()
        self.velocity_initiale = self.velocity.copy()

        self.compteur_Loss_position = 0
        self.nombre_choc = 0
        self.compteur_Loss_velocity = 0

    def wall_time(self): # On calcul le temps de colision avec la paroie, la première particule qui s'est choquée avec la paroie

        temps = np.where(self.velocity>0, (([self.L-self.sigma, self.W-self.sigma])-self.position)/self.velocity, (self.sigma-self.position)/self.velocity)
        temps = np.where(temps > 0, temps, np.inf)
        w_time = np.min(temps)

        particle,direction = np.unravel_index(np.argmin(temps), self.position.shape)
        return w_time, particle, direction


    def pair_time(self): # On calcul le temps de collision entre deux particules, les deux premières particule qui se sont choqués
        deltaV = self.velocity[self.l]-self.velocity[self.m]
        deltaP = self.position[self.l]-self.position[self.m]

        A = np.sum(deltaV**2, axis = 1)
        B = 2*np.sum(deltaV*deltaP, axis = 1)
        C = np.sum(deltaP**2, axis = 1)-(2*self.sigma)**2

        Delta = B**2 - 4*A*C

        temps = np.where((C>0) & (Delta >= 0) & (B<0), (-B - np.sqrt(Delta))/(2*A), np.inf) # On verifie que les conditions sur A, B et C sont verifiées

        arg_t_min = np.argmin(temps)

        return temps[arg_t_min], self.l[arg_t_min], self.m[arg_t_min]

    def vitesse_choc(self,particle1, particle2): # On calcul les vitesses après le chocs entre deux particules

        U = (self.position[particle1]-self.position[particle2])/(2*self.sigma)
        V = self.velocity[particle1]-self.velocity[particle2]
        self.velocity[particle1] -= U*np.dot(U,V)
        self.velocity[particle2] += U*np.dot(U,V)


    def md_step(self, current_frame):

        ke_start = (self.velocity**2).sum()/2.   # énergie cinétique

        pressure = -1 # pression
        current_time = 0

        if current_frame == self.nframes // 2: # On inverse toutes les vitesses à la moitié du temps totale de simulation
          self.velocity *= -1

        w_time, particle, direction = self.wall_time()
        c_time, particle1, particle2 = self.pair_time()
        next_time = min(w_time, c_time)

        while current_time + next_time < self.simul_time:
            current_time += next_time
            self.position += next_time * self.velocity

            if w_time < c_time : # Une particule touche d'abord une paroie
                self.velocity[particle, direction] = - self.velocity[particle, direction]

            else : # deux particules se touchent en premier
                self.vitesse_choc(particle1,particle2)
                self.nombre_choc += 1

            w_time, particle, direction = self.wall_time()
            c_time, particle1, particle2 = self.pair_time()
            next_time = min(w_time, c_time)

        self.position += (self.simul_time-current_time) * self.velocity

        # On calcul les erreurs des positions et des vitesses entre la fin et le début de la simulation
        if current_frame == self.nframes:
          self.compteur_Loss_position = np.sum(np.abs(self.position-self.position_initiale))
          self.compteur_Loss_velocity = np.sum(np.abs(self.velocity+self.velocity_initiale))


        assert math.isclose(ke_start,  (self.velocity**2).sum()/2.)  # On vérifie que l'énergie cinétique est conservée

        return pressure


    def __str__(self):   # On print les positions et les vitesses des particules
        p = np.array2string(self.position)
        v = np.array2string(self.velocity)
        return 'pos= '+p+'\n'+'vel= '+v+'\n'

class Animate:
    def __init__(self, simul):
        self.simul = simul
        self.fig, self.ax = plt.subplots(figsize=(5, 5))  # Initialisation des graphiques
        self.circles = EllipseCollection(widths=2*simul.sigma, heights=2*simul.sigma, angles=0, units='x',
                                         offsets=simul.position, transOffset=self.ax.transData)  # circles at position
        self.ax.add_collection(self.circles)
        self.ax.axis("equal")
        self.segment = [[[0, 0], [0, simul.W], [simul.L, simul.W], [simul.L, 0], [0, 0]]]  # simulation cell
        self.line = LineCollection(self.segment, colors='#000000')  # draw square
        self.ax.add_collection(self.line)

        self.ax.set_xlim(left=-0.5, right=self.simul.L+0.5)  # plotting limits on screen
        self.ax.set_ylim(bottom=-0.5, top=self.simul.L+0.5)
        self._ani = 0

    def init(self):  # this is the first thing drawn to the screen
        self.circles.set_offsets(self.simul.position)

    def anim_step(self, m):  # m is the number of calls that have occurred to this function
        #print('anim_step m = ', m) # Commented out to avoid excessive output
        if m == 0:
            time.sleep(1)

        self.simul.md_step(m)  # perform simulation step
        self.circles.set_offsets(self.simul.position)  # update positions on screen

    def go(self, nframes):
        self._ani = animation.FuncAnimation(self.fig, func=self.anim_step, frames=nframes,
                                            repeat=False, interval=10, init_func=self.init)
        plt.close(self.fig) # Close the plot to prevent it from showing twice
        return HTML(self._ani.to_jshtml()) # Return HTML for Colab display

"""Nous observons à l'aide de la simulation que les particules reviennent exactement à la même position initiale.
Notre code fonctionne donc bien.
(temps d'exécution 33 s)
"""

# 1. Configuration pour Colab (Mode JavaScript)
rc('animation', html='jshtml')

# 2. Création de la figure
fig, ax = plt.subplots()
x = np.linspace(0, 2*np.pi, 100)
line, = ax.plot(x, np.sin(x))

# 3. Fonction d'animation (appelée à chaque image)
def update(frame):
    # On décale l'onde sinusoïdale
    line.set_ydata(np.sin(x + frame / 10.0))
    return line,

# 4. Création de l'objet animation
# IMPORTANT : Il faut assigner le résultat à une variable ("anim" ici)
# sinon le "garbage collector" de Python risque de supprimer l'animation.
anim = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True)

# 5. Affichage (Evite d'avoir une image statique en double)
plt.close() # Ferme la figure statique précédente
anim # Affiche le lecteur interactif


def main():
    np.random.seed(1)  # set random numbers to be always the same
    nframes = 500
    simulation = Simul(simul_time=0.2, sigma=1, L=50, W = 50, eps = 10**(-4), nframes=nframes, velo = [10,0])  # sigma particle radius # L box size
    print(simulation.__doc__)  # print the documentation from the clas

    animate = Animate(simulation)
    ani_html = animate.go(nframes=nframes)  # number of animation steps
    display(ani_html) # Display the HTML animation



if __name__ == '__main__':
    main()

"""Nous réalisons une animation avec une vitesse supérieur.

Nous remarquons que les particules ne reviennent pas à la position initiale.  qui permet de mettre en evidence la précense d'erreur numérique.

(temps d'éxecution 1min)
"""

# 1. Configuration pour Colab (Mode JavaScript)
rc('animation', html='jshtml')

# 2. Création de la figure
fig, ax = plt.subplots()
x = np.linspace(0, 2*np.pi, 100)
line, = ax.plot(x, np.sin(x))

# 3. Fonction d'animation (appelée à chaque image)
def update(frame):
    # On décale l'onde sinusoïdale
    line.set_ydata(np.sin(x + frame / 10.0))
    return line,

# 4. Création de l'objet animation
# IMPORTANT : Il faut assigner le résultat à une variable ("anim" ici)
# sinon le "garbage collector" de Python risque de supprimer l'animation.
anim = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True)

# 5. Affichage (Evite d'avoir une image statique en double)
plt.close() # Ferme la figure statique précédente
anim # Affiche le lecteur interactif


def main():
    np.random.seed(1)  # set random numbers to be always the same
    nframes = 1000
    simulation = Simul(simul_time=0.2, sigma=1, L=50, W = 50, eps = 10**(-4), nframes=nframes, velo = [12,0])  # sigma particle radius # L box size
    print(simulation.__doc__)  # print the documentation from the clas
    animate = Animate(simulation)
    ani_html = animate.go(nframes=nframes)  # number of animation steps
    display(ani_html) # Display the HTML animation



if __name__ == '__main__':
    main()

"""Nous arretons les simulations qui demandent trop de temps et ne sont plus très pertinantes. (Elles sont très visuelles)

(temps d'exécution 0.3 seconde pour 1000 frames)
"""

def main(M):
    np.random.seed(1)  # graine plus facile pour détecter les erreurs
    nframes = 1000
    compteur_Lp = 0
    compteur_temps = 0
    for m in range(M):
      debut = time.time()
      simulation = Simul(simul_time=0.5, sigma=1, L=50, W = 50, eps = 10**(-4), nframes=nframes, velo = [15,0])  # sigma particle radius # L box size

      for j in range(nframes+1):
        simulation.md_step(j)
      fin = time.time()
      compteur_Lp += simulation.compteur_Loss_position
      compteur_temps += fin-debut
    return compteur_Lp/M , compteur_temps/M

M = 10 # moyenne sur M valeur



if __name__ == '__main__':
    Lp, temps = main(M)
    print("L'erreur moyenne sur la position est :", Lp)
    print("Le temps d'exécution moyen est:", temps)

"""Nous souhaitons maintenant observer l'évolution de l'erreur des positions initiales et finales en fonction de la vitesse initiale.

Nous avons d'avantage de contrôle sur la vitesse plutôt que sur le temps totale de simulation ie les n frames qui sont entiers.


Nous remarquons bien l'appartition de différents régimes.


(temps d'exécutions 5s)
"""

def main(N, M, V_i, V_f):
    np.random.seed(1)  # graine plus facile pour détecter les erreurs
    nframes = 200
    L_position = []
    L_velocity = []
    N_choc = []
    for i in np.linspace(V_i,V_f,N):
      compteur_Loss_position  = 0
      compteur_nombre_choc = 0
      compteur_Loss_velocity = 0
      for m in range(M):
        simulation = Simul(simul_time=0.5, sigma=1, L=50, W = 50, eps = 10**(-4), nframes=nframes, velo = [i,0])  # sigma particle radius # L box size

        for j in range(nframes+1):
          simulation.md_step(j)
        compteur_Loss_position += simulation.compteur_Loss_position
        compteur_Loss_velocity += simulation.compteur_Loss_velocity
        compteur_nombre_choc += simulation.nombre_choc
      L_position.append(compteur_Loss_position/M)
      L_velocity.append(compteur_Loss_velocity/M)
      N_choc.append(compteur_nombre_choc/M)
    return L_position, L_velocity, N_choc

N = 10 # Nombre de valeur
M = 1 # moyenne sur M valeur
V_i = 1 # Vitesse initiale
V_f = 20 # Vitesse finale


if __name__ == '__main__':
    L_position, L_velocity, N_choc = main(N, M, V_i, V_f)

fig, axs = plt.subplots(4, 2, figsize=(10, 20))

# Premier sous-graphe (en haut à gauche)
axs[0, 0].plot(np.log(np.linspace(V_i,V_f,N)),  np.log(L_position), 'b-', label='log(L_position)')
axs[0, 0].set_title("Courbe loglog de l'erreur des positions en fonction de la vitesse")
axs[0, 0].set_ylabel(r"log(|$r_f - r_i$|)")
axs[0, 0].set_xlabel(r"log(v_i)")
axs[0, 0].legend()

# Deuxième sous-graphe (en haut à droite)
axs[0, 1].plot(np.linspace(V_i,V_f,N), L_position, 'b-')
axs[0, 1].set_title("Courbe de l'erreur des positions en fonction de la vitesse")
axs[0, 0].set_ylabel(r"|$r_f - r_i$|")
axs[0, 0].set_xlabel(r"v_i")
axs[0, 1].legend()

# Troisième sous-graphe (en bas à gauche)
axs[1, 0].plot(np.linspace(V_i,V_f,N), L_velocity, 'g-')
axs[1, 0].set_title("Courbe de l'erreur des vitesses en fonction de la vitesse")
axs[1, 0].set_ylabel(r"|$v_f - v_i$|")
axs[1, 0].set_xlabel(r"v_i")
axs[1, 0].legend()

# Quatrième sous-graphe (en bas à droite)
axs[1, 1].plot(np.linspace(V_i,V_f,N), N_choc , 'r-')
axs[1, 1].set_title("Courbe du nombre de chocs en fonction de la vitesse")
axs[1, 1].set_ylabel(r"$N_{choc}$")
axs[1, 1].set_xlabel(r"v_i")
axs[1, 1].legend()

# cinquième sous-graphe (en bas à gauche)
axs[2, 0].plot(np.log(np.linspace(V_i,V_f,N)), np.log(L_velocity), 'g-')
axs[2, 0].set_title("Courbe loglog de l'erreur des vitesses en fonction de la vitesse")
axs[2, 0].set_ylabel(r"log(|$v_f - v_i$|)")
axs[2, 0].set_xlabel(r"log(v_i)")
axs[2, 0].legend()

# sixième sous-graphe (en bas à droite)
axs[2, 1].plot(np.log(np.linspace(V_i,V_f,N)), np.log(N_choc) , 'r-')
axs[2, 1].set_title("Courbe loglog du nombre de chocs en fonction de la vitesse")
axs[2, 1].set_ylabel(r"log($N_{choc}$)")
axs[2, 1].set_xlabel(r"log(v_i)")
axs[2, 1].legend()

# septième sous-graphe (en bas à gauche)
axs[3, 0].plot(np.linspace(V_i,V_f,N), L_velocity/(max(L_velocity)), 'g-', label=' velocity')
axs[3, 0].plot(np.linspace(V_i,V_f,N), L_position/(max(L_position)), 'b-', label='position)')
axs[3, 0].set_title("Courbe normalisées de l'erreur des vitesses et positions en fonction de V_i")
axs[3, 0].set_ylabel(r"position et vitesse normalisées")
axs[3, 0].set_xlabel(r"v_i")
axs[3, 0].legend()

# huitième sous-graphe (en bas à droite)
axs[3, 1].plot(np.linspace(V_i,V_f,N), np.log(N_choc) , 'r-', label=' N_choc ')
axs[3, 1].set_title("Courbe loglog du nombre de chocs en fonction de la vitesse")
axs[3, 1].set_ylabel(r"log($N_{choc}$)")
axs[3, 1].set_xlabel(r"log(v_i)")
axs[3, 1].legend()


plt.tight_layout()
plt.subplots_adjust(hspace=0.3, wspace=0.7)
plt.show()

"""Nous réalisons d'avantage de points avec N et M plus importants pour mieux interpréter nos résulats.

(temps d'exécution 1h)
"""

def main(N, M, V_i, V_f):
    np.random.seed(1)  # graine plus facile pour détecter les erreurs
    nframes = 1000
    L_position = []
    L_velocity = []
    N_choc = []
    for i in np.linspace(V_i,V_f,N):
      compteur_Loss_position  = 0
      compteur_nombre_choc = 0
      compteur_Loss_velocity = 0
      for m in range(M):
        simulation = Simul(simul_time=0.5, sigma=1, L=50, W = 50, eps = 10**(-4), nframes=nframes, velo = [i,0])  # sigma particle radius # L box size
        for j in range(nframes+1):
          simulation.md_step(j)
        compteur_Loss_position += simulation.compteur_Loss_position
        compteur_Loss_velocity += simulation.compteur_Loss_velocity
        compteur_nombre_choc += simulation.nombre_choc
      L_position.append(compteur_Loss_position/M)
      L_velocity.append(compteur_Loss_velocity/M)
      N_choc.append(compteur_nombre_choc/M)
    return L_position, L_velocity, N_choc

N = 500
M = 10
V_i = 1
V_f = 35


if __name__ == '__main__':
    L_position, L_velocity, N_choc = main(N, M, V_i, V_f)